<HTML LANG="en">
  <!-- Note for maintenance: be able to load in the subway, avoid assets,
       prefers ASCII. Contact me at nico@puffer.fish. -->
  <HEAD>
    <META CHARSET="utf-8">
    <TITLE>~nico</TITLE>
    <LINK REL="me" HREF="https://mastodon.puffer.fish/@nico">
    <STYLE>
    BODY {
      width: 96vw;
      padding: auto;
      background-color: rgb(30 105 64);
      color: rgb(246 234 220);
      font-style: normal;
      font-weight: 400;
      font-family: ui-sans-serif, sans-serif;
      font-size: 16pt;
      text-align: left;
      column-width: 27ch;
      column-count: auto;
      column-fill: auto;
      column-gap: 6ch;
      column-rule-style: none;
    }
    ::SELECTION { background-color: rgb(177 212 80); }
    H1 { text-align: center; font-size: 34pt; font-weight: 900; }
    H2 { text-align: left; font-size: 19pt; font-weight: 700; }
    A, A:visited, A:hover { color: unset; text-decoration: underline; }
    CODE { font-family: ui-monospace, monospace; font-size: 13pt; }
    STRONG { font-weight: 600; }
    EM { font-style: italic; }
    </STYLE>
  </HEAD>
  <BODY>
    <H1 ID="nicolas">Nicolas and the electronic waste land of the WWW</H1>

    <P>
      Hello, my name is Nicolas and I try to write recreative computer programs
      for fun and non-profits, all of which I sometimes share below.  Tip: click
      on the date to obtain the permanant link to the log entry.  <CODE>&copy;
      2015-2025</CODE>.
    </P>

    <P>
      You can contact me via electronic mailing at <CODE>nico@puffer.fish</CODE>
      and Mastodon at <CODE>@nico@puffer.fish</CODE>.  Some code of mine are
      available on-line.
    </P>

    <H2 ID="20250617">
      The essence of writing an algorithm.
    </H2>

    <P>
      <A HREF="#20250617">June 2025</TIME></A> &mdash; In the twelfth century,
      Persian mathematician Muhammad al-Khwarizmi started codifying the use of
      numbers and their various applications, leading to the notion of
      algorithms.  Today, we use algorithms everywhere: to automate processes,
      speed up boring work, or entertain us.  Yet, despite the years flying by
      and the rise of electronics, there is still an essential but often
      forgotten way of structuring algorithms which, when misunderstood, creates
      inefficient computing systems.
    </P>

    <P>
      For the moment, forget about Big O, Turing machines, and all the other
      formal stuff from academia, that is, let's focus not on the function but
      on the form of our ideas.  An algorithm is a sequence of steps, or at
      least I said so.  Whether it is sentences written on a page, boxes linked 
      with arrows in a graphic, or mathematical functions in a computation
      machine, there will always be these steps and sequences.
    </P>

    <P>
      The steps form phases in a pipeline: if A is followed by B, then B shall
      not occur before A.  That is not to say the implementation of both A and B
      cannot be tasks happening concurrently, but it is that for the same data
      flowing within the pipeline, its treatment by step A should finish before 
      step B starts.
    </P>

    <P>
      Naturally, this pipelining behaviour could be exploited to increase the
      raw performance and speed of the implementation, as it is in modern RISC
      micro-computers and real-time software: when processing the third step of
      the pipeline on some data, you can also be processing the second step for
      the next data, while the fourth step is processing the previous data.
      One may even go further by trying to do runtime analysis of data
      dependencies to dynamically execute steps out of order and achieve more
      optimal execution.
    </P>

    <P>
      But be advised not to be too crazy!  Especially, do not disguise the
      pipeline as something it is not.  Maybe your data represents actors in a
      scene, sending messages to one another; but the algorithm certainly isn't.
      And remember Niklaus Wirth's "Algorithms + Data Structures = Programs", an
      idea he believed in so strongly that it became the eponym of one of his
      books.
    </P>

    <P>
      And when it comes to the function, that's the place where you should be
      thinking about your algorithm's properties: from determinism or scaling to
      statefulness versus statelessness.  They are inherited from your needs,
      not universals.  But one universal is for sure that one shouldn't hide
      from the pipe.
    </P>
  </BODY>
</HTML>
