% vi: set ft=tex cc=51 ts=3 sw=3 et         : vi %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{beamer}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[frenchb]{babel}
\usepackage{tikz}

%%% DOCUMENT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO(nico): syntax for Hardy
\lstdefinelanguage{Hardy}{
  morekeywords={emit,to,OFF,ON},
  sensitive=true,
}

\lstdefinelanguage{Rust}{
  morekeywords={let,fn,if,else,unsafe},
  sensitive=true,
}

\title{Spécifications de programmes réactifs}
\author{PAUL Nicolas}
% Yes, it's ugly, but it works...
\institute[]{nicolas.paul1@etu.univ-orleans.fr}
\date{17 juillet 2025}

\titlegraphic{%
   \includegraphics[width=1.8cm]{lifo.jpg}}

\usetheme{Madrid}

\begin{document}

%%% TITRE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\titlepage
\end{frame}

%%% PLAN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Plan}

\begin{enumerate}
\item Plan
\item Programmation réactive
\item Vérification formelle
\item Types et logiques avec OCamlFRP
\item Vérification déductive avec Hardy
\item Conclusion
\end{enumerate}
\end{frame}

%%% PROG. REACTIVE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Programmation réactive}

\begin{itemize}
\item Deux catégories de systèmes :
      transformationnels et réactionnels.
\item Contraintes temporelles.
\item Paradigme dédié pour la programmation
      réactive synchrone ou asynchrone.
\item Plusieurs implantations en utilisation:
      \begin{itemize}
      \item Lustre (86) dans Ansys SCADE ; ou
      \item Rx.js (18) sur le Web.
      \end{itemize}
\end{itemize}
\end{frame}

% TODO: schema transformatif vs. reactif

%%% VERIFICATION FORMELLE %%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Vérification formelle}

\begin{itemize}
\item Importante mais souvent ignorée.
\item Trois étapes :
      \begin{enumerate}
      \item spécification,
      \item synthétisation, et
      \item satisfaction.
      \end{enumerate}
\item Des méthodes existent pour automatiser :
      BNF, MATLAB/Simulink, Astrée, \&c.
\end{itemize}
\end{frame}

%%% TYPES ET LOGIQUES %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Types et logiques, OCamlFRP}

\begin{itemize}
\item Lien entre logiques et types ?
\item Oui, la correspondance Hurry-Coward.
\item Le typage, familier aux ingénieurs.
\item Typage faible, algébrique et dépendant.
\item Exemple avec Ada chez Thalès et Lockheed
      Martin.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Types et logiques, OCamlFRP}

\begin{lstlisting}[language=C]
Value
get(size_t i)
{
   return array[i];
}
\end{lstlisting}

\begin{itemize}
\item OoB si $i >= n$ ou $i < 0$.
\item Contrôle manuel de la validité au call-site.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Types et logiques, OCamlFRP}

\begin{lstlisting}[language=Rust]
fn get() -> Option<Value> {
   if i < 0 || i >= array.len() {
      unsafe { Some(array.get_unchecked(i)) }
   } else {
      None
   }
}
\end{lstlisting}

\begin{itemize}
\item OoB sous contrôle et explicites.
\item Mais verbreux à chaque call-site.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Types et logiques, OCamlFRP}

\begin{lstlisting}[language=Ada]
type Index is range 1 .. 5;
type Bounded_Array is array (Index) of Value;
function Get(i: Index) returns Value
is
   My_Array: Bounded_Array = [V1, V2, V3, V4, V5];
begin
   return My_Array (i);
end Get;
\end{lstlisting}

\begin{itemize}
\item OoB impossible : le code ne compilera pas si
      on appelle Get avec une valeur possiblement
      nulle.
\item Le call-site reste simple.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Types et logiques, OCamlFRP}

Qu'est-ce que la FRP ?

\begin{itemize}
\item Paradigme déclaratif.
\item Fran (89) pour remplacer DirectX Animations.
\item $Behavior_{\alpha} = Time \longrightarrow
      \alpha$
\item $Event_{\alpha} = Time \times \alpha$
\item Tutoriel officiel de Fran.
\item Mais fuites mémoires et temporelles.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Types et logiques, OCamlFRP}

Une alternative, OCamlFRP :

\begin{itemize}
\item Fuites réglées par la co-itération.
\item $Stream = (S \longrightarrow T \times S)
      \times S$
\item Arrows de HUGHES John (00).
\item Expressif, concis, système de type puissant.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Types et logiques, OCamlFRP}

\includegraphics[width=9cm]{arrows.png}

(Source : Haskell Wiki)
\end{frame}

\begin{frame}[fragile]
\frametitle{Types et logiques, OCamlFRP}

Démonstration d'un jeu Snake.

\begin{lstlisting}[language=Caml]
let score =
   arr (func s -> { s with score = s+1 })
(* ... *)

let snake = calculate_head >>> move_head
let hit = new_apple >>> score
let apple = collision >>> choice hit move_tail
let render = fanin id id >>> fanout make_scene id

let game = loop (snake >>> apple >>> render) s0
\end{lstlisting}
\end{frame}

%%% VERIF. DEDUCTIVE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Vérification déductive, Hardy}

\begin{itemize}
\item Déduire des lemmes depuis la spécification
      et la synthèse.
\item Si toutes les lemmes sont prouvés alors la
      synthèse satisfait la spécification.
\item Moins de unit-tests et proche du code final.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Vérification déductive, Hardy}

D'où Hardy :

\begin{itemize}
\item Langage impératif pour les programmes
      réactifs synchrones.
\item Linear Temporal Logic :
      $P | \neg \phi | \phi \lor \psi
       | \mathit{X} \phi | \phi \mathit{U} \psi
       | \phi \mathit{R} \psi | \mathit{G} \phi
       | \mathit{F} \phi$.
\item Safety and liveness properties.
\item Automates de Büchi et triplets de Hoare.
\item Compilation et intégration avec Why3.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Vérification déductive, Hardy}

Démonstration d'une télécommande TV.

\begin{lstlisting}[language=Hardy]
OFF:
| button_power {
  // Power button pressed, turn the TV on!
  vol  := 20;
  chan := "1";
  emit true to powered;
  emit vol to volume;
  emit chan to channel;
} => ON
\end{lstlisting}
\end{frame}

%%% CONCLUSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Conclusion}

\begin{itemize}
\item Augmentation du nombre de systèmes réactifs
      dans le futur.
\item Le paradigme de programmation réactive se
      popularise dans des domaines non-critiques.
\item La vérification formelle reste rare en
      dehors de quelques industries.
\item Mais certaines méthodes sont de plus en plus
      adoptées ! Rust ?
\item Simplifier l'expérience utilisateur peut
      aider.
\end{itemize}
\end{frame}

\end{document}
